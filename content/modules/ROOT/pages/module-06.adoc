= Lab Guide: Creating an Execution Environment with ansible-builder
:doctype: book
:experimental:
:notoc:
:toc-title: Table of Contents
:nosectnums:
:icons: font

_A guide to automating the creation and customization of containerized execution environments using the `ansible-builder` utility and the integrated Visual Studio Code environment._

== Lab Briefing

In previous challenges, you authored, tested, and validated your custom Ansible collection. This final deployment step requires packaging all content (collections, Python dependencies, and system requirements) into a repeatable, version-controlled Execution Environment (EE) container image using `ansible-builder`.

This exercise focuses on using the Ansible Builder 3.x schema features to efficiently define and build a custom EE directly from the VS Code environment.



== Enhanced Developer Experience

`ansible-builder` is part of the comprehensive Ansible Development Tools (ADT) suite. The Ansible VS Code extension is actively providing an Enhanced VS Code integration that simplifies interaction with these tools. For EE creation specifically, the roadmap includes the upcoming EE Builder Web UI, which will provide a graphical interface within VS Code to easily build, test, and debug your EEs.

== Lab Guide: Hands-On Tasks

We will define an Execution Environment configuration file, use `ansible-builder create` to inspect the generated `Containerfile`, and finally build the custom EE image using Podman (the default container runtime).

=== Task 1: Define the Execution Environment Definition File

The EE configuration is defined in `execution-environment.yml`. To access the features of modern Ansible tooling, we must explicitly declare `version: 3` in the definition file.

. *Open the collection directory in VS Code:*
+
Ensure you are operating in the directory containing your collection, which should contain the root configuration files.
+
[source,bash]
----
cd /home/rhel/myansibleproject/collections/ansible_collections/mynamespace/mycollection/
----

. *Create the `execution-environment.yml` file:*
+
In the root of your collection directory, create a new file named `execution-environment.yml`.

. *Add the EE blueprint content:*
+
Copy and paste the following content into `execution-environment.yml`. This configuration defines the base image, includes the collection dependencies (which implicitly pull requirements from `requirements.txt` and `requirements.yml`), and explicitly adds the system dependency (`cowsay`) needed for your custom module.
+
[source,yaml]
----
version: 3
images:
  base_image:
    name: registry.redhat.io/ansible-automation-platform-24/ee-minimal-rhel8:latest
dependencies:
  galaxy: requirements.yml
  python: requirements.txt
options:
  # MANDATORY: Specifies the package manager path for downstream Red Hat images
  package_manager_path: /usr/bin/microdnf
additional_build_steps:
  append_final:
    # Ensure cowsay system package is present for our custom module
    - RUN microdnf install cowsay -y
----
+
[IMPORTANT]
.Microdnf Requirement
====
Because the base image (`ee-minimal-rhel8:latest`) is built on UBI-minimal, which uses `microdnf`, you must specify `package_manager_path: /usr/bin/microdnf` in the options section for the build to succeed.
====

. *Save the file:*
+
Save the `execution-environment.yml` file.

=== Task 2: Review the Generated Containerfile (Dry Run)

Before executing the full build, we can use the `ansible-builder create` command to generate the `Containerfile` and build context directory (`context/`). This is helpful for debugging the build steps without spending time on the full image assembly.

. *Run the `ansible-builder create` command in the VS Code Terminal:*
+
Execute the following command in the active terminal to generate the build context.
+
[source,bash]
----
ansible-builder create
----
+
_Expected Output:_ This creates the `context/` directory containing the `Containerfile` and all necessary build artifacts.

. *Inspect the generated Containerfile:*
+
In the VS Code file explorer, locate `context/Containerfile` and open it. Review the sequential stages (Base, Galaxy, Builder, Final) generated by `ansible-builder`, confirming your custom `microdnf install cowsay` instruction is correctly inserted in the final stage.

=== Task 3: Build and Tag the Custom Execution Environment

Now we will execute the full build process and assign a specific tag to the final image.

. *Run the `ansible-builder build` command:*
+
Use the `-t` flag to tag your new EE image and the `-v 3` flag for detailed output.
+
[source,bash]
----
ansible-builder build -t mynamespace/mycollection-ee:latest -v 3
----
+
[NOTE]
.Verbosity Flag
====
The `-v 3` flag specifies the verbosity level of the output and is not related to the `version: 3` schema defined in your YAML file. This command executes the container build across four internal stages: Base, Galaxy, Builder, and Final.
====

. *Verify the image creation:*
+
After the build completes successfully, use your container runtime tool to verify the local image exists.
+
[source,bash]
----
podman images | grep mynamespace
----
+
You should see `mynamespace/mycollection-ee` listed.

. *Test the custom EE:*
+
Run a quick test inside the container to verify the custom collection and module dependency were successfully packaged.
+
[source,bash]
----
podman run mynamespace/mycollection-ee:latest ansible-doc -t module mynamespace.mycollection.cowsay
----
+
This command should display the documentation for your custom module, confirming the environment is correctly packaged.

== Next Steps

You have successfully packaged your automation content into an Execution Environment using `ansible-builder` 3.x. This image is now ready for promotion to an Automation Hub or deployment via Automation Controller.

_Click the **Next Challenge** button below to continue the workshop._
